---
title: WriteUp
titleTemplate: ':title - NewStar CTF 2024'
---

# Game

本题主要考察pwntools库中recv和send的使用  
在5s时间内，只能输入小于等于10的数，使这些数字相加>999  
所以手动输入就不可能了，当然搞个宏什么的当鼠鼠没说  
所以简单粗暴写个py脚本就行  

```python
from pwn import *

p = remote("ip", port)
for i in range(112):
    p.sendlineafter(b': ', b'9')

p.interactive()
```

> 根据椰奶师傅@hacbit 的补充解法，本题可以利用 scanf 的 %d 格式解析漏洞来拿 shell。  
> scanf %d 在解析非数字的时候，由于解析到非数字停止解析的特性，导致遇到非数字字符时不会抛出异常，也不会覆盖原来的值，会直接返回。  
> 比如对于这个语句 `scanf("%d", &value);` 假设 value 原本是 10，如果我输入 `"1a"` ，那么会解析到 `"1"` 的输入，而忽略后面的`"a"`，这时候 value 会被改成 1  
> 那么我们设想一下：如果不输入数字，直接输入 `"a"` ，这时候是直接忽略了吧，然后 scanf 什么数字也解析不到，也就无法对 value 做修改，是的，这时候 value 的值没有变！并且由于这个解析的异常，会导致输入缓冲区无法被刷新，也就是说下一次调用的时候，下一个 scanf 会继续解析 `"a"` 。  
> 这么一想，是不是很符合这道题，那么我只需要输入寥寥几个字符，比如： `"10a"` ，第一次调用 scanf 会解析出 10，并且给结果加上 10，然后后面每次循环，scanf 都会尝试对剩下的 `"a"` 进行解析，但是由于不是数字会被忽略，所以这个多出来的 `"a"` 就一直在！导致你后面的输入也都没有用了，因为 scanf 永远无法跳过这个 `"a"` 字符解析到后面的输入！最终就导致——一直加 10，结果大于 999 从而拿到 shell
