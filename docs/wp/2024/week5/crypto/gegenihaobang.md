---
titleTemplate: ':title | WriteUp - NewStar CTF 2024'
---

# 格格你好棒

```
from Crypto.Util.number import *
import random

flag = b'******'
m = bytes_to_long(flag)
a = getPrime(1024)
b = getPrime(1536)
p = getPrime(512)
q = getPrime(512)
r = random.randint(2**8, 2**9)
assert ((p+2*r) * 3*a + q) % b < 70

c = pow(m, 0x10001, p*q)

print(f'c =', c)
print(f'a =', a)
print(f'b =', b)

'''
c = 75671328500214475056134178451562126288749723392201857886683373274067151096013132141603734799638338446362190819013087028001291030248155587072037662295281180020447012070607162188511029753418358484745755426924178896079516327814868477319474776976247356213687362358286132623490797882893844885783660230132191533753
a = 99829685822966835958276444400403912618712610766908190376329921929407293564120124118477505585269077089315008380226830398574538050051718929826764449053677947419802792746249036134153510802052121734874555372027104653797402194532536147269634489642315951326590902954822775489385580372064589623985262480894316345817
b = 2384473327543107262477269141248562917518395867365960655318142892515553817531439357316940290934095375085624218120779709239118821966188906173260307431682367028597612973683887401344727494920856592020970209197406324257478251502340099862501536622889923455273016634520507179507645734423860654584092233709560055803703801064153206431244982586989154685048854436858839309457140702847482240801158808592615931654823643778920270174913454238149949865979522520566288822366419746
'''
```

## 格密码基础

[格定义](https://blog.csdn.net/jayq1/article/details/140872034)

[矩阵乘法](https://zhuanlan.zhihu.com/p/158776486)

## NTRU密码

![](/assets/images/wp/2024/week5/gegenihaobang_1.png)

- 考虑格

![](/assets/images/wp/2024/week5/gegenihaobang_2.png)

![](/assets/images/wp/2024/week5/gegenihaobang_3.png)

- 更多条件

![](/assets/images/wp/2024/week5/gegenihaobang_4.png)

![](/assets/images/wp/2024/week5/gegenihaobang_5.png)

- 分析

![](/assets/images/wp/2024/week5/gegenihaobang_6.png)

### 明确目标

找到私钥（f，g）

### 构造格

由公钥公式得到 g = h*f + k*p 因为右边只有两项，确定 n 维数为 2，且只有 h 和 p 已知，得知最后我们要构造的格的最后一列是 h，p，再推出L前面相乘的向量是（f,k），最后再补上前一列 1，0。

### 解密

用 LLL 算法得到最短向量 v 后，对照当初设想的 v= （f，g），令 f = v[0]，g = v[1]，
获得 f，g 后，带入解密式子，因为 r 是临时密钥，无从得知，所以我们先模上 p，再模上 g，消去 r。最后再乘上 f 关于模 g 的逆元，求得 m。

## 解析

从题目和描述，知识点指向 格密码

题目给了一个断言:

``((p+2*r) * 3*a + q) % b < 70``，可以看成 ``h = ((p-2·r) · 3·a + q) mod b < 70``

其中 r 和 h 都是有范围的，最大的范围 r 也是 2^14 - 2^15 之间，对于计算机而言相当小，可以爆破，所以当成已知数
化简式子，把模消去

``(p-2·r) · 3·a +k·b = h - q``

和 NTRU 的式子相似 (NTRU: ``c = (r*h + m) % p``)

构造:

```
L = [[1, 3·a],
     [0,  b ]]
```

发现``(p-r,k)L = (p-2·r, -q+h)=v``且：

![](/assets/images/wp/2024/week5/gegenihaobang_7.png)

## Exp

```
#sagemath
from Crypto.Util.number import *
from tqdm import tqdm
c = 
a = 
b = 

L = Matrix(ZZ,[[1,3*a],
               [0,b]])
p,q = L.LLL()[0]    # 这里的[0]是取其中的最小向量
p,q = abs(p),abs(q)
# 爆破r和h
for r in tqdm(range(2**8,2**9)):
    for h in range(70):
        pp = p - 2*r
        qq = q + h
        phi = (pp-1)*(qq-1)
        if gcd(phi,65537) != 1:
            continue
        m = power_mod(c,inverse_mod(65537,phi),pp*qq)
        if b'flag' in long_to_bytes(m):
            print(r,h)
            print(pp,qq)
            print(long_to_bytes(m))
            print(long_to_bytes(m)==b'flag{u_are_@_master_of_latt1ce_Crypt0gr@phy}')
            exit(0)
```

建议升级一下 sagemath 版本，参照这位师傅的文章[Arch 下的 Sage 安装 - Shin's Blog (shinichicun.top)](https://shinichicun.top/posts/arch%E4%B8%8B%E7%9A%84sage%E5%AE%89%E8%A3%85/)

## 碎碎念（与解题无关）

一开始听群里面说想学格密码，于是在 week5 打算出一个

出 NTRU 吗？ ——有模板，不方便改

出背包吗？ ——我当时认为掌握超数列就能 python 手撕(后记：是我见识小了)

在笔记中寻找许久，便把窃取目标盯上了 xenny 师傅的格密码课程的 P3

直接抄违背了出题初心，但 P3 的解题内核——自己动手推导式子构造格——始终吸引着我（在这对因为我窃取题目的行为而受伤的师傅们说声对不起！）

那么我就转向修改参数，以往的 rsa 题目，在我手动调试验证各个参数大小关系的时候，都是能满足自身的关系的。

但在这题 assert ((p-r) * a + q) % b < 50 似乎发生了变化，随意 getPrime() 的参数根本满足不了前面这个式子，换句话来说，这个式子太过于严谨了，怎么能取到那么合适的值，把 h 从 1536 位降到 5 位

答案是 getPrime() + 自己构造

让我们看原题目是怎么写的

```
a = getPrime(1024)
b = getPrime(1536)

p = getPrime(512)
q = getPrime(512)
r = random.randint(2**14, 2**15)
assert ((p-r) * a + q) % b < 50
```

关键步 ``((p-r) * a + q) % b < 50``，那么我们只用先 ``getPrime() 生成 p，q，r，a，然后手动取一个（或者取随机数）h 就行，让b = ((p-r) * a + q) - h 就行``

等想到这步时，我才发现 ((p-r) * a + q) 的位数和 b 相近（前者最大项是 p·a ），这才能使得 h = ((p-r) * a + q) - b 成立，而不是 h = ((p-r) · a + q) - K·b

代码附上:

```
a = getPrime(1024)


p = getPrime(512)
q = getPrime(512)
r = random.randint(2**8, 2**9) #这个涉及到解题的速度，我这台电脑2个/s，遍历[2**8, 2**9]要2分钟，遍历[2**14, 2**15]要2小时，速度好像也和后面构造出的格有关

print(((p+2*r) * 3*a + q).bit_length())  # 要为a的位数＋p的位数
while ((p+2*r) * 3*a + q).bit_length() != a.bit_length() + p.bit_length():
    a = getPrime(1024)
    p = getPrime(512)
    q = getPrime(512)
    r = random.randint(2**8, 2**9)

print(((p+2*r) * 3*a + q))

b = ((p+2*r) * 3*a + q) - 58   # 可改式子的系数，或者是自己搞一个式子，核心就是p*a最大，b的位数就是a的位数＋p的位数，b具体值是((p+2*r) * 3*a + q) - h ， h的值自己拟定
h = 58
print('p,q =',[p,q])
print('a,r =',[a,r])
print('b,h =',[b,h])
exit()
```

调试的方法

可以改 a，p，q 的位数，r 的范围需要后面在解题代码中看看跑的速度来调整，注意：b 的位数要大于 2 倍的 p 的位数（推导见 Hermite 定理）

式子也能改，式子的灵魂就是最大项 p·a 与 b 在位数上相近，需要自己爆破的数字很小且可控，式子的未知数个数是 5 个，只有 2 个知道范围，k 和 p，q 都不知，式子和导向用格级规约 LLL 来解决

式子各项的系数，r 的可以随意改，只要不接近 p//r，exp 只需要改动 pp = p - t*r 中的 t ；

a 的系数改动就要改格中 a 的系数

q 的系数改动还不太清楚，改完 exp 就跑不动，也许是向量内不平衡

h 改动涉及爆破范围的扩大与缩小，只需要对应的改动 exp 的 h

``for h in range(50):``

完整出题代码如下

```
from Crypto.Util.number import *
import random

flag = b''
m = bytes_to_long(flag)




if 0:
    a = getPrime(1024)


    p = getPrime(512)
    q = getPrime(512)
    r = random.randint(2**8, 2**9)

    print(((p+2*r) * 3*a + q).bit_length())  # 要为a的位数＋p的位数
    print(((p+2*r) * 3*a + q))

    b = ((p+2*r) * 3*a + q) - 58   # 可改式子的系数，或者是自己搞一个式子，核心就是p*a最大，b的位数就是a的位数＋p的位数，b具体值是((p+2*r) * 3*a + q) - h ， h的值自己拟定
    h = 58
    print('p,q =',[p,q])
    print('a,r =',[a,r])
    print('b,h =',[b,h])
    exit()

p,q =
a,r =
b,h =

assert ((p+2*r) * 3*a + q) % b < 70

c = pow(m, 0x10001, p*q)

print(f'c = {c}')
print(f'a = {a}')
print(f'b = {b}')
先将if 0 ：改为1，执行临近代码块，获取[p,q] [a,r] [b,h] 然后直接复制到下方，将if 1：改成0，获取c，a，b
提取r，复制
放到解题脚本调试
#sagemath
from Crypto.Util.number import *
from tqdm import tqdm
c = 75671328500214475056134178451562126288749723392201857886683373274067151096013132141603734799638338446362190819013087028001291030248155587072037662295281180020447012070607162188511029753418358484745755426924178896079516327814868477319474776976247356213687362358286132623490797882893844885783660230132191533753
a = 99829685822966835958276444400403912618712610766908190376329921929407293564120124118477505585269077089315008380226830398574538050051718929826764449053677947419802792746249036134153510802052121734874555372027104653797402194532536147269634489642315951326590902954822775489385580372064589623985262480894316345817
b = 2384473327543107262477269141248562917518395867365960655318142892515553817531439357316940290934095375085624218120779709239118821966188906173260307431682367028597612973683887401344727494920856592020970209197406324257478251502340099862501536622889923455273016634520507179507645734423860654584092233709560055803703801064153206431244982586989154685048854436858839309457140702847482240801158808592615931654823643778920270174913454238149949865979522520566288822366419746

L = Matrix(ZZ,[[1,3*a],
               [0,b]])
p,q = L.LLL()[0]    # 这里的[0]是取其中的最小向量
p,q = abs(p),abs(q)
爆破r和h
for r in tqdm(range(308,2**9)):
    for h in range(70):
        pp = p - 2r
        qq = q + h
*        phi = (pp-1)*(qq-1)
        if gcd(phi,65537) != 1:
            continue
        m = power_mod(c,inverse_mod(65537,phi),pp*qq)
        if b'flag' in long_to_bytes(m):
            print(r,h)
            print(pp,qq)
            print(long_to_bytes(m))
            print(long_to_bytes(m)==b'既定flag{}')
            exit(0)
```

先用 r 替换 ``for r in tqdm(range(2**8,2**9)):`` 中的 ``2**8`` ，跳过遍历环节，看看能否得到结果。如果可以，那么再换回成 ``2**8``

看看遍历速度和所需时间，这里需要 2 分钟，实际上解题只需要 22 秒

两个 sagemath 版本（Windows 的 9.3 和 Linux 的 10.x）都要测试速度，以免新生因为环境问题而困扰

更换了参数和式子，也算半个魔改了（